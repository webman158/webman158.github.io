<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript,传智播客教育,JavaScript高级," />










<meta name="description" content="constructor 属性 1 每个原型对象都有一个 constructor 属性2 constructor 描述的是创建对象的构造函数3 p.constructor === Person 结果为true4 对象的constructor属性是由构造函数的prototype提供的注意在写的时候，不要把值写成字符串的构造函数12345678910111213141516171819function">
<meta name="keywords" content="JavaScript,传智播客教育,JavaScript高级">
<meta property="og:type" content="article">
<meta property="og:title" content="javaScript-高级-第二天笔记">
<meta property="og:url" content="http://biedongda.com/2017/12/12/javaScript-高级-第二天笔记/index.html">
<meta property="og:site_name" content="一个学徒的世界">
<meta property="og:description" content="constructor 属性 1 每个原型对象都有一个 constructor 属性2 constructor 描述的是创建对象的构造函数3 p.constructor === Person 结果为true4 对象的constructor属性是由构造函数的prototype提供的注意在写的时候，不要把值写成字符串的构造函数12345678910111213141516171819function">
<meta property="og:image" content="http://biedongda.com/2017/12/12/javaScript-高级-第二天笔记/images/完整的原型链结构图.jpg">
<meta property="og:updated_time" content="2018-01-06T00:58:19.380Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="javaScript-高级-第二天笔记">
<meta name="twitter:description" content="constructor 属性 1 每个原型对象都有一个 constructor 属性2 constructor 描述的是创建对象的构造函数3 p.constructor === Person 结果为true4 对象的constructor属性是由构造函数的prototype提供的注意在写的时候，不要把值写成字符串的构造函数12345678910111213141516171819function">
<meta name="twitter:image" content="http://biedongda.com/2017/12/12/javaScript-高级-第二天笔记/images/完整的原型链结构图.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://biedongda.com/2017/12/12/javaScript-高级-第二天笔记/"/>





  <title>javaScript-高级-第二天笔记 | 一个学徒的世界</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一个学徒的世界</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不敢面对的永远受其折磨</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://biedongda.com/2017/12/12/javaScript-高级-第二天笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="前端学徒">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个学徒的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">javaScript-高级-第二天笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-12T09:05:27+08:00">
                2017-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><blockquote>
<p>1 每个原型对象都有一个 <code>constructor</code> 属性<br>2 <code>constructor</code> 描述的是创建对象的构造函数<br>3 <code>p.constructor === Person</code> 结果为true<br>4 对象的<code>constructor</code>属性是由构造函数的prototype提供的<br><strong>注意在写的时候，不要把值写成字符串的构造函数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">19</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 默认情况下，原型对象只包含：constructor 和 __proto__ 属性</span></div><div class="line"><span class="built_in">console</span>.log( Person.prototype );</div><div class="line"><span class="comment">// constructor 属性 指向了当前构造函数</span></div><div class="line"><span class="built_in">console</span>.log( Person.prototype.constructor );</div><div class="line"><span class="built_in">console</span>.log( Person.prototype.constructor === Person ) <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">// 实例对象可以直接访问到原型对象中的属性和方法</span></div><div class="line"><span class="built_in">console</span>.log(p.constructor);</div><div class="line"><span class="built_in">console</span>.log(p.constructor === Person);</div><div class="line"></div><div class="line"><span class="comment">// 这么做可以，但是，不推荐这么做！</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person.prototype.constructor();</div><div class="line"><span class="built_in">console</span>.log(p);</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> p.constructor();</div><div class="line"><span class="built_in">console</span>.log(p1);</div></pre></td></tr></table></figure></p>
</blockquote>
<a id="more"></a>
<h3 id="面向对象特征介绍"><a href="#面向对象特征介绍" class="headerlink" title="面向对象特征介绍"></a>面向对象特征介绍</h3><blockquote>
<p>面向对象的三大特征：封装、继承、 多态（了解）</p>
</blockquote>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><blockquote>
<p>封装：将复杂的操作包裹起来，让简单的留在外面<br>函数是对 具体过程的封装。<br>对象是对 行为(方法)和数据(属性)的封装。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">''</span></div><div class="line"><span class="keyword">var</span> age = <span class="number">19</span>;</div><div class="line"><span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name: <span class="string">'xiaoming'</span>,</div><div class="line">    age: <span class="number">19</span>,</div><div class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><blockquote>
<p>子类可以使用从父类继承的属性和方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    string name;</div><div class="line">    <span class="keyword">int</span> age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Student : Person &#123; // c#</div><div class="line"><span class="comment">// class Student extends Person &#123; // java</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Student stu = <span class="keyword">new</span> Student();</div><div class="line">stu.name</div><div class="line"><span class="comment">// 即：让某个类型的对象获得另一个类型的对象的属性的方法</span></div></pre></td></tr></table></figure>
<h4 id="多态（基于强类型）-了解"><a href="#多态（基于强类型）-了解" class="headerlink" title="多态（基于强类型） - 了解"></a>多态（基于强类型） - 了解</h4><blockquote>
<p>javaScript是弱类型语言，js中没有多态的特征</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。 </div><div class="line"></div><div class="line">Animal ani = <span class="keyword">new</span> Animal();</div><div class="line">Dog dog = <span class="keyword">new</span> Dog();</div><div class="line">dog.jiao();</div><div class="line">Cat cat = <span class="keyword">new</span> Cat();</div><div class="line">cat.jiao();</div><div class="line"></div><div class="line">Animal dog1 = <span class="keyword">new</span> Dog();</div><div class="line">Animal cat1 = <span class="keyword">new</span> Cat();</div><div class="line"></div><div class="line">动物 animal = <span class="keyword">new</span> 子类(); <span class="comment">// 子类： 麻雀、狗、猫、猪、狐狸...</span></div><div class="line">动物 animal = <span class="keyword">new</span> 狗();</div><div class="line">动物 animal = <span class="keyword">new</span> 猫();</div><div class="line"><span class="comment">// animal.叫();</span></div></pre></td></tr></table></figure>
<h3 id="JavaScript中的继承"><a href="#JavaScript中的继承" class="headerlink" title="JavaScript中的继承"></a>JavaScript中的继承</h3><blockquote>
<ul>
<li>拿来主义：自己没有，别人有，把别人的拿过来借用或者让其成为自己的，这样就实现了js中的继承</li>
<li>继承最终的目的（表现形式）：让一个对象能够使用另外一个对象中的属性和方法</li>
<li>实现继承的方式：<ol>
<li>混入式继承</li>
<li>原型式继承</li>
<li>经典继承</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="混入式继承"><a href="#混入式继承" class="headerlink" title="混入式继承"></a>混入式继承</h4><blockquote>
<p>一个对象可以继承自任意多个其他对象，把这个方式称为：混入继承(extend)<br>思路：将其他对象中的成员添加到自己身上<br>对象可以继承自任意的对象</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>:<span class="string">"女娲"</span>, <span class="attr">age</span>: <span class="number">1</span>, <span class="attr">gender</span>: <span class="string">"female"</span>&#125;;</div><div class="line"><span class="keyword">var</span> o2 = &#123;<span class="attr">grade</span>: <span class="string">"三年级二班"</span>, <span class="attr">score</span>: <span class="number">100</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// o2 继承 o1</span></div><div class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> k <span class="keyword">in</span> o1 ) &#123;</div><div class="line">    <span class="comment">// 遍历o1对象，将该对象的属性和方法添加一份到o2上</span></div><div class="line">    o2[k] = o1[k];</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(o2);<span class="comment">//现在o2继承到了o1对象的属性和方法</span></div><div class="line"></div><div class="line"><span class="comment">// 如果希望 o2 可以继承自任意的对象. 所以为了简化继承的代码</span></div><div class="line"><span class="comment">// 给 o2 提供一个方法, 叫 extend（名字是随意取的，extend有继承、拓展的含义）</span></div><div class="line">o2.extend = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</div><div class="line">        <span class="keyword">this</span>[k] = obj[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">o2.extend(o1);  <span class="comment">// o2 继承 o1</span></div><div class="line">o2.extend(&#123;</div><div class="line">    name:<span class="string">"haxi"</span>, </div><div class="line">    age: <span class="number">10</span>, </div><div class="line">    gender: <span class="string">"male"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><blockquote>
<p>如果要让一个对象使用某些属性和方法，可以把它们放到原型对象中，因为对象继承自原型对象，所以对象就可以访问这些属性和方法。把这种继承方式称为：原型继承<br>其实就是 <code>实例对象</code> 能够直接使用 <code>原型对象</code> 中的属性和方法<br><code>实例对象</code> 继承自 <code>原型对象</code><br><strong>原型继承的3种实现方式</strong></p>
<ol>
<li>利用对象的动态特性  添加成员</li>
<li>覆盖原型对象        添加成员</li>
<li>利用混入继承        添加成员<br><strong>记住：不要修改任何 内置对象（js默认提供的） 的属性和方法！！！</strong></li>
</ol>
</blockquote>
<h6 id="利用对象的动态特性"><a href="#利用对象的动态特性" class="headerlink" title="利用对象的动态特性"></a>利用对象的动态特性</h6><blockquote>
<p>动态性：可以在任意时刻给对象添加属性和方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将需要的属性、方法添加到原型对象中</span></div><div class="line">Person.prototype.legs = <span class="number">2</span>;</div><div class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'hi'</span>)&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">// 现在实例对象就可以直接访问到原型上的方法或属性</span></div><div class="line">p.sayHi();</div></pre></td></tr></table></figure>
<h5 id="覆盖原型对象"><a href="#覆盖原型对象" class="headerlink" title="覆盖原型对象"></a>覆盖原型对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意：这样会把默认的原型对象覆盖！</span></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="comment">// 目的：为了与默认的原型对象的结构保持一致</span></div><div class="line">    <span class="comment">// 推荐添加该属性，也可以省略</span></div><div class="line">    <span class="keyword">constructor</span>: Person,</div><div class="line"></div><div class="line">    sayHi: function() &#123;&#125;,</div><div class="line">    sayNo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">    sayYouAgin: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'hi boy'</span>)&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line">p.sayYouAgin();</div></pre></td></tr></table></figure>
<h5 id="利用混入继承添加原型成员"><a href="#利用混入继承添加原型成员" class="headerlink" title="利用混入继承添加原型成员"></a>利用混入继承添加原型成员</h5><blockquote>
<p>给原型对象添加<code>extend</code>方法来拓展原型对象上的对象或是属性</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Person.prototype.extend = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</div><div class="line">        <span class="keyword">this</span>[k] = obj[k];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Person.prototype.extend(&#123;</div><div class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'sayHi'</span>)&#125;,</div><div class="line">    sayNo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'sayNo'</span>)&#125;,</div><div class="line">    seeYouAgin: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'seeYouAgin'</span>)&#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(Person.prototype);</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line">p.seeYouAgin();</div></pre></td></tr></table></figure>
<h5 id="经典继承-Object-create"><a href="#经典继承-Object-create" class="headerlink" title="经典继承 - Object.create"></a>经典继承 - Object.create</h5><blockquote>
<ul>
<li>语法：<code>var newObj = Object.create( 参数对象 )</code></li>
<li>作用：接收一个参数对象，返回一个新对象，并且参数对象会变成新对象的原型对象！</li>
<li>最终: 返回的新对象 继承自 参数对象!</li>
</ul>
<p>提出者：Douglas Crockford(道格拉斯 克罗克福德) JSON作者 《js语言精粹》<br><a href="http://json.org/json-zh.html" target="_blank" rel="external">JSON的介绍</a><br><code>Object.create</code> 是ES5提供的方法（IE9+ 开始支持）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 语法</span></div><div class="line"><span class="keyword">var</span> o1 = &#123; </div><div class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"hello，i am jj"</span>);</div><div class="line">    &#125;,</div><div class="line">    running: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'go！'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(o1);</div><div class="line"><span class="built_in">console</span>.log(o2);</div><div class="line">o2.sayHi();</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>该方法是让参数对象作为该方法返回值的原型对象</strong><br>上述代码<code>o2.__proto__ === o1</code> 返回true<br>注意该方法返回的对象的原型对象上没有<code>constructor</code>属性，所以我们在封装兼容方法的时候也没必要考虑<code>constructor</code>属性。</p>
</blockquote>
<ul>
<li>模拟实现<code>Object.create</code>方法<blockquote>
<p>实现思路：<br>1 创建对象 —&gt; 必须要有一个 <code>构造函数</code> &amp;&amp; <code>new 构造函数()</code> 会返回一个新对象<br>2 让创建出来的对象继承自参数对象 —&gt; 改变构造函数的原型指向</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="built_in">Object</span>.create) &#123;</div><div class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">        <span class="comment">// 构造函数</span></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">        <span class="comment">// 继承</span></div><div class="line">        F.prototype = obj;</div><div class="line">        <span class="comment">// 返回实例对象</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123; </div><div class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"hello，i am jj"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(obj);</div><div class="line"><span class="built_in">console</span>.log(o);</div></pre></td></tr></table></figure>
<ul>
<li>实现方法的兼容性<blockquote>
<p>1 判断浏览器是否支持 <code>Object.create()</code><br>2 如果浏览器支持这个方法，就直接使用 <code>Object.create()</code><br>3 如果浏览器不支持，就自己实现 <code>Object.create</code> 方法<br><em>实现兼容的原则：能使用浏览器提供的就用，浏览器不支持了，我们再自己实现！</em></p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> create = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</div><div class="line">    <span class="comment">// 使用能力检测</span></div><div class="line">    <span class="keyword">if</span> ( <span class="built_in">Object</span>.create ) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create( obj );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = obj;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123; </div><div class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"hello，i am jj"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> o = create(obj);</div><div class="line"><span class="built_in">console</span>.log(o)</div></pre></td></tr></table></figure>
<ul>
<li>Object.create 的其他作用<blockquote>
<p>通过 Object.create 能够创建一个真正空的对象！<br>通过传入参数 null， 能够创建一个没有任何属性的对象！</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="built_in">console</span>.log(obj);<span class="comment">// No properties</span></div><div class="line">obj.toString(); <span class="comment">// 会报错！</span></div></pre></td></tr></table></figure>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><blockquote>
<p>要求：能够描述任意对象的原型链结构</p>
</blockquote>
<h4 id="理解原型链"><a href="#理解原型链" class="headerlink" title="理解原型链"></a>理解原型链</h4><blockquote>
<p>对象有原型对象，原型对象也是对象，所以，原型对象也有原型对象，这样一环扣一环，就形成了一条链式结构，叫做：原型链</p>
<ul>
<li>基于原型链重新理解 原型继承：<br>任何对象都有一条原型链存在，所谓的继承就是通过任何手段，改变原型链的层次结构，那么，对象通过访问原型链中的属性或者方法，从而实现继承</li>
<li>绘制原型链逻辑图需要考虑三个对象：</li>
</ul>
<ol>
<li>构造函数</li>
<li>原型对象</li>
<li>实例对象<br><strong>绘制原型链结构图就是绘制：构造函数、原型对象、实例对象之间的三角形关系！</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="comment">// 原型链结构</span></div><div class="line"><span class="comment">// -&gt; 代表 __proto__ 属性</span></div><div class="line"><span class="comment">// o -&gt; Object.prototype -&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"><span class="comment">// 原型链结构</span></div><div class="line"><span class="comment">// arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// 自定义对象呢？DOM对象呢？</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name =<span class="number">123</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(p);</div><div class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__); <span class="comment">// Object.prototype</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__); <span class="comment">// null</span></div><div class="line"></div><div class="line"><span class="comment">// 关系：</span></div><div class="line"><span class="number">1</span> 通过构造函数能够访问到原型对象</div><div class="line">    prototype</div><div class="line"></div><div class="line"><span class="number">2</span> 通过原型对象访问到构造函数</div><div class="line">    <span class="keyword">constructor</span></div><div class="line"></div><div class="line">3 构造函数创建了实例对象</div><div class="line">    new</div><div class="line"></div><div class="line">4 实例对象 和 原型对象</div><div class="line">    实例对象通过 __proto__ 能够访问到原型对象</div><div class="line">    怎么查看对象的原型对象？ __proto__</div><div class="line">    各个对象之间通过 __proto__ 联系起来 形成的原型链</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><blockquote>
<p>new 创建新对象的时候就已经指定了新对象的原型对象！也就是原型链也就定下来了！并且整个原型链不会再发生改变，即使手动改变也不会发生变化。</p>
</blockquote>
<h4 id="Object对象与其他对象的关系"><a href="#Object对象与其他对象的关系" class="headerlink" title="Object对象与其他对象的关系"></a>Object对象与其他对象的关系</h4><blockquote>
<p>原型链结构的最上层是 <code>Object.prototype</code>，任何对象都直接或间接的继承自<code>Object.prototype</code></p>
</blockquote>
<h4 id="数据的存储注意点："><a href="#数据的存储注意点：" class="headerlink" title="数据的存储注意点："></a>数据的存储注意点：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">基本数据类型：存储的是数据本身。</div><div class="line"></div><div class="line">复杂数据类型（引用类型）：存储的是数据的引用，</div><div class="line">也就是说：</div><div class="line"></div><div class="line">引用类型有两个存储区域，一个存储数据本身，一个存储引用</div><div class="line"></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">num</span>: <span class="number">123</span> &#125;;</div><div class="line"><span class="keyword">var</span> o2 = o1;</div><div class="line">o2 = &#123;<span class="attr">name</span>: <span class="string">"cc"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="keyword">var</span> car = &#123;<span class="attr">name</span>: <span class="string">"Benz"</span>&#125;;</div><div class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>: <span class="string">"youyou"</span>, <span class="attr">c</span>: car&#125;;</div></pre></td></tr></table></figure>
<h4 id="构造函数和原型的一些结论"><a href="#构造函数和原型的一些结论" class="headerlink" title="构造函数和原型的一些结论"></a>构造函数和原型的一些结论</h4><blockquote>
<p>1 只要是函数 就有 <code>prototype</code> 属性<br>3 <code>prototype</code> 默认含有 <code>constructor</code> 和<code>__proto__</code>属性的对象<br>4 <code>constructor</code> 属性指向当前构造函数<br>5 函数的 <code>prototype</code> 属性的值默认继承自 <code>Object.prototype</code><br>6 <code>prototype</code> 是一个对象类型（大部分情况下）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数是js的一等公民</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype); <span class="comment">// function</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;&#125;;</div><div class="line"><span class="comment">// 只要是函数就有 prototype 属性。方法也是，但是一般内置方法是没有的prototype属性的</span></div><div class="line"><span class="built_in">console</span>.log(obj.foo.prototype);</div><div class="line"><span class="comment">// toString 这种内置方法是没有 prototype 属性的！！！</span></div><div class="line"><span class="built_in">console</span>.log(obj.toString.prototype);</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="构造函数与实例对象的关系"><a href="#构造函数与实例对象的关系" class="headerlink" title="构造函数与实例对象的关系"></a>构造函数与实例对象的关系</h4><ul>
<li><p>绘制一个实例对象的原型链结构图</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">// p、Person、Person.prototype 之间的关系</span></div><div class="line"><span class="comment">// Person.prototype、Object.prototype、Object之间的关系</span></div></pre></td></tr></table></figure>
</li>
<li><p>经典的 “对象原型和函数三角形”：</p>
<blockquote>
<p>1 对象p 是 Person 的实例<br>2 p 继承自 Person.prototype<br>3 p.<strong>proto</strong> 就是 Person.prototype</p>
</blockquote>
</li>
</ul>
<h4 id="函数的原型链"><a href="#函数的原型链" class="headerlink" title="函数的原型链"></a>函数的原型链</h4><blockquote>
<p>对象的原型链结论</p>
<ul>
<li>对象都有原型对象，对象默认继承自原型对象 （p -&gt; Person.prototype）</li>
<li>函数被定义后，默认就有prototype，原型属性也是对象 (Person的prototype)</li>
<li>函数的原型属性默认继承自Object.prototype（Person.prototype -&gt; Object.prototype）</li>
<li>原型对象中的 constructor 指向对象的构造函数（p.constructor === Person）</li>
<li>所有的函数都是 Function 的实例（ new Function() ）</li>
<li>函数也是对象！<br>1 只要是函数就有 <code>prototype</code> 属性<br>2 只要是对象就有 <code>__proto__</code> 属性<br><strong>因为函数也是对象，所有，函数既有：prototype属性 又有 <strong>proto</strong> 属性</strong></li>
<li>可以理解为：<br>所有的函数都是 <code>Function</code> 的实例（ <code>new Function()</code> ）<br><code>var fn = function() {}</code></li>
</ul>
</blockquote>
<h4 id="Function和普通函数的关系"><a href="#Function和普通函数的关系" class="headerlink" title="Function和普通函数的关系"></a>Function和普通函数的关系</h4><blockquote>
<ul>
<li><p>函数作为构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="comment">// Person是构造函数</span></div><div class="line"><span class="comment">// p是构造函数Person的实例对象</span></div><div class="line"><span class="comment">// 对象继承自构造函数的原型属性，或者说：对象的__proto__ 就是 构造函数的prototype</span></div><div class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
<li><p>函数作为对象<br><strong>函数(作为对象)都继承自Function.prototype</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 自定义函数：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果把函数foo看作是对象，则：</span></div><div class="line"><span class="comment">// foo是构造函数Function的实例</span></div><div class="line"><span class="comment">// 并存在关系：</span></div><div class="line">foo.__proto__ === <span class="built_in">Function</span>.prototype</div><div class="line"></div><div class="line"><span class="comment">// 类比 Person 和 p的关系</span></div><div class="line"><span class="comment">// Person ==&gt; Function</span></div><div class="line"><span class="comment">// p      ==&gt; foo</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 内置函数：</span></div><div class="line"><span class="comment">// Array是Function的实例，继承自Function.prototype</span></div><div class="line"><span class="comment">// Object是Function的实例，继承自Function.prototype</span></div><div class="line"></div><div class="line"><span class="comment">// 经典：</span></div><div class="line"><span class="comment">// Function（当作是对象来看待） 是 Function（当作是构造函数来看待） 的实例，继承自Function.prototype，即：</span></div><div class="line"><span class="comment">// Function.__proto__ === Function.prototype</span></div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="案例练习-绘制完整的原型链图"><a href="#案例练习-绘制完整的原型链图" class="headerlink" title="案例练习 - 绘制完整的原型链图"></a>案例练习 - 绘制完整的原型链图</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="comment">// Foo、Function、Function.prototype、Object.prototype</span></div><div class="line"></div><div class="line"><span class="comment">// 2 Function 也是函数的情况</span></div><div class="line"><span class="comment">// Function.__proto__ === Function.prototype</span></div><div class="line"></div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line"><span class="comment">// 4 完整的原型链结构图</span></div></pre></td></tr></table></figure>
<p><strong>注意：原型链在画的时候是从实例对象自身开始的，结束到null，但是实例对象本身以及null都不在原型链上的</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(p)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(p)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(Person)); <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(p.isPrototypeOf(p));    <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="comment">// Person 的原型链：</span></div><div class="line">Person -&gt; <span class="built_in">Function</span>.prototype -&gt; <span class="built_in">Object</span>.prototype -&gt; <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="comment">// p 的原型链：</span></div><div class="line">p -&gt; Person.prototype -&gt; <span class="built_in">Object</span>.prototype -&gt; <span class="literal">null</span>;</div></pre></td></tr></table></figure></p>
<h4 id="原型链的思考题"><a href="#原型链的思考题" class="headerlink" title="原型链的思考题"></a>原型链的思考题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"hi, I am "</span> + <span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line">Person.prototype = <span class="literal">null</span>;</div><div class="line"><span class="built_in">console</span>.log(Person.prototype); <span class="comment">//null</span></div><div class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Person(<span class="string">"ErumHuang"</span>, <span class="number">22</span>);</div><div class="line"><span class="built_in">console</span>.log(me.__proto__); <span class="comment">//&#123;&#125;  why ？？？</span></div><div class="line"><span class="comment">// 实测发现，将Person.prototype重新赋值为值类型数据的取值（null，undefined，NaN，数字，字符串，布尔值），实例对象me.__proto__的值都是Object.prototype(会跳过自身构造函数的原型对象也就是值类型)</span></div><div class="line"><span class="comment">// 可以通过 me.__proto__ === Object.prototype // true 侧面验证</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"hi, I am "</span> + <span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> nullProto = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">Person.prototype = nullProto;</div><div class="line"><span class="built_in">console</span>.log(Person.prototype); <span class="comment">//&#123;&#125;   （注意此处的对象是一个什么属性都没有的空对象）</span></div><div class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Person(<span class="string">"ErumHuang"</span>, <span class="number">22</span>);</div><div class="line"><span class="built_in">console</span>.log(me.__proto__); <span class="comment">//undefined ？？？</span></div></pre></td></tr></table></figure>
<h3 id="站在原型链的角度来看-instanceof-运算符"><a href="#站在原型链的角度来看-instanceof-运算符" class="headerlink" title="站在原型链的角度来看 instanceof 运算符"></a>站在原型链的角度来看 <code>instanceof</code> 运算符</h3><blockquote>
<ul>
<li>语法：实例对象 instanceof 构造函数</li>
<li><p>作用：用来判断<code>构造函数的prototype属性所指向的对象</code> 是否在<code>被检测对象的原型链上</code>，如果在返回true，否则返回：false<br>与 <code>isPrototypeOf()</code> 方法的作用相同！<br><img src="/2017/12/12/javaScript-高级-第二天笔记/images/完整的原型链结构图.jpg" alt="完整的原型链" title="完整的原型链"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</div><div class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Fn); <span class="comment">// ? </span></div><div class="line"><span class="comment">// f 的原型链：</span></div><div class="line"><span class="comment">// f -&gt; Fn.prototype（默认的原型） -&gt; Object.prototype -&gt; null</span></div><div class="line"></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="comment">// 修改 Fn.prototype 的指向</span></div><div class="line">Fn.prototype = <span class="keyword">new</span> Foo();</div><div class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> Fn); <span class="comment">// ? </span></div><div class="line"><span class="comment">// 因为修改了Fn.prototype的指向，现在Fn.prototype也就是 Foo的实例对象，不在f的原型链上。</span></div><div class="line"></div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Fn();</div><div class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Fn); <span class="comment">// ?</span></div><div class="line"><span class="comment">// f1 的原型链：</span></div><div class="line"><span class="comment">// f1 -&gt; Fn.prototype（Foo的实例对象） -&gt; Foo.prototype -&gt; Object.prototype -&gt; null</span></div><div class="line"></div><div class="line"><span class="comment">// 任何对象 instanceof Object 都是返回true,因为任何对象的原型链上都有Object.prototype</span></div><div class="line"><span class="built_in">console</span>.log( f <span class="keyword">instanceof</span> <span class="built_in">Object</span> );  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( f1 <span class="keyword">instanceof</span> <span class="built_in">Object</span> ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( &#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span> ); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( [] <span class="keyword">instanceof</span> <span class="built_in">Object</span> ); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 这个需要知道完整的原型链图，尤其是函数的原型链部分,参考上面完整的原型链图</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true   // Object.prototype 在实例对象 Function 的原型链上</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">// true   // Object.prototype 在实例对象 Object 的原型链上</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true  // Function.prototype 在实例对象 Function 的原型链上</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true    // Function.prototype 在实例对象 Object 的原型链上</span></div></pre></td></tr></table></figure>
</li>
<li><p>规律：<br><strong>创建对象以后</strong><br>1 如果没有改变构造函数的prototype属性，则返回true<br>2 如果改变了构造函数的prototype属性，则返回false</p>
</li>
</ul>
</blockquote>
<h3 id="站在原型链的角度来看-in-运算符"><a href="#站在原型链的角度来看-in-运算符" class="headerlink" title="站在原型链的角度来看 in 运算符"></a>站在原型链的角度来看 <code>in</code> 运算符</h3><p><em>in 运算符相关的使用说明在 JavaScript基础-第四天笔记中有说明</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">19</span>;</div><div class="line">&#125;;</div><div class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'age'</span> <span class="keyword">in</span> p);		<span class="comment">// age属性在 p对象上</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'say'</span> <span class="keyword">in</span> p);		<span class="comment">// say方法在 Person.prototype</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'toString'</span> <span class="keyword">in</span> p);	<span class="comment">// toString方法在 Object.prototype</span></div><div class="line"></div><div class="line"><span class="comment">// 总结:只要属性或是方法能被对象访问到都返回 true，不管属性是对象自身有的还是原型上的。</span></div></pre></td></tr></table></figure></p>
<p><a href="http://www.cnblogs.com/wangfupeng1988/p/3979290.html" target="_blank" rel="external">参考链接-深入理解javascript原型和闭包</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 上面文章的评论</span></div><div class="line">而且每个对象其实都有<span class="keyword">constructor</span>属性 指向创建它的函数。</div><div class="line">如 &#123;&#125;.constructor 指向<span class="built_in">Object</span>函数</div><div class="line"><span class="keyword">new</span> Foo().constructor指向Foo函数</div><div class="line">而<span class="built_in">Function</span>.constructor指向了<span class="built_in">Function</span>自己！！！，也说明了<span class="built_in">Function</span>这个函数是自己创建了自己！！！，这样一看<span class="built_in">Function</span>.__proto__指向<span class="built_in">Function</span>.prototype也就能解释得通了。</div><div class="line">所有对象（除了调用<span class="built_in">Object</span>.create(<span class="literal">null</span>)）都继承了<span class="built_in">Object</span>。</div><div class="line">而<span class="built_in">Object</span>又是由<span class="built_in">Function</span>创建的。</div><div class="line">那么是不是可以说<span class="built_in">Function</span>函数才是js的根基？<span class="built_in">Function</span>创造了一切？</div><div class="line"></div><div class="line"></div><div class="line">通过<span class="built_in">Object</span>.create(<span class="literal">null</span>)创建的对象是没有原型链的，因此并不是所有对象的.__proto__最终都指向<span class="built_in">Object</span>.prototype</div><div class="line"></div><div class="line"></div><div class="line">牛逼，楼主是怎么把这些东西都理解清楚了的啊，都看几次忘几次??我觉得这种东西需要形成一定的理论体系，理解javascript这样设计的作用，如果只是单独的看某一个点，看了就忘很正常</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">Function</span>.prototype 为什么是一个函数？？？</div></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
            <a href="/tags/传智播客教育/" rel="tag"># 传智播客教育</a>
          
            <a href="/tags/JavaScript高级/" rel="tag"># JavaScript高级</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/07/javaScript-高级-第一天笔记/" rel="next" title="javaScript-高级-第一天笔记">
                <i class="fa fa-chevron-left"></i> javaScript-高级-第一天笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/13/javaScript-高级-第三天笔记/" rel="prev" title="javaScript-高级-第三天笔记">
                javaScript-高级-第三天笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">前端学徒</p>
              <p class="site-description motion-element" itemprop="description">web前端开发，移动端开发是一个很好的工种，希望你能和我携手共进前端职业发展</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#constructor-属性"><span class="nav-number">1.</span> <span class="nav-text">constructor 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象特征介绍"><span class="nav-number">2.</span> <span class="nav-text">面向对象特征介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#封装"><span class="nav-number">2.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承"><span class="nav-number">2.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态（基于强类型）-了解"><span class="nav-number">2.3.</span> <span class="nav-text">多态（基于强类型） - 了解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript中的继承"><span class="nav-number">3.</span> <span class="nav-text">JavaScript中的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#混入式继承"><span class="nav-number">3.1.</span> <span class="nav-text">混入式继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型式继承"><span class="nav-number">3.2.</span> <span class="nav-text">原型式继承</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#利用对象的动态特性"><span class="nav-number">3.2.0.1.</span> <span class="nav-text">利用对象的动态特性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#覆盖原型对象"><span class="nav-number">3.2.1.</span> <span class="nav-text">覆盖原型对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#利用混入继承添加原型成员"><span class="nav-number">3.2.2.</span> <span class="nav-text">利用混入继承添加原型成员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#经典继承-Object-create"><span class="nav-number">3.2.3.</span> <span class="nav-text">经典继承 - Object.create</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型链"><span class="nav-number">4.</span> <span class="nav-text">原型链</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#理解原型链"><span class="nav-number">4.1.</span> <span class="nav-text">理解原型链</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#注意点"><span class="nav-number">4.1.1.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object对象与其他对象的关系"><span class="nav-number">4.2.</span> <span class="nav-text">Object对象与其他对象的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据的存储注意点："><span class="nav-number">4.3.</span> <span class="nav-text">数据的存储注意点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数和原型的一些结论"><span class="nav-number">4.4.</span> <span class="nav-text">构造函数和原型的一些结论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数与实例对象的关系"><span class="nav-number">4.5.</span> <span class="nav-text">构造函数与实例对象的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数的原型链"><span class="nav-number">4.6.</span> <span class="nav-text">函数的原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function和普通函数的关系"><span class="nav-number">4.7.</span> <span class="nav-text">Function和普通函数的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例练习-绘制完整的原型链图"><span class="nav-number">4.8.</span> <span class="nav-text">案例练习 - 绘制完整的原型链图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型链的思考题"><span class="nav-number">4.9.</span> <span class="nav-text">原型链的思考题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#站在原型链的角度来看-instanceof-运算符"><span class="nav-number">5.</span> <span class="nav-text">站在原型链的角度来看 instanceof 运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#站在原型链的角度来看-in-运算符"><span class="nav-number">6.</span> <span class="nav-text">站在原型链的角度来看 in 运算符</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">前端学徒</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
